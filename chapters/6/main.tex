% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Conclusion and Future Work}\label{chapter:conc}

\section{Conclusion}
In this thesis, we presented a static type inference for Python based on SMT solving. We proved SMT to be capable of simulating a complex structure like the type system of Python and to be useful in solving a complicated system of constraints like the ones imposed by the type inference rules.

The goal of the thesis was to provide a static type inference which is sound in terms of the static type checking but not necessarily complete. From the perspective of this thesis, soundness is more important than completeness because accepting type errors can incur significant costs compared to rejecting a correct program.

We took a new approach for tackling the type inference problem by encoding the type system in an SMT solver, doing whole program analysis, collecting constraints from the whole program and querying the SMT solver for the types that each variable is allowed to have at runtime which satisfy the imposed constraints.

Particularly, we defined a static type system for Python 3 which makes the static type inference possible. We also defined subtyping relationships between the types in this type system and presented the limitations imposed on the dynamic nature of Python due to having a static type system (Chapter \ref{chapter:background}).

In addition, we presented the encoding of this static type system in the SMT solver Z3 and how we make use of different Z3 constructs (e.g., data types and uninterpreted functions) to provide a concise encoding (Chapter \ref{chapter:ts}).

We also provided type inference rules for all the Python constructs that we support and presented a complete implementation for the type inference algorithm (Chapter \ref{chapter:ti}). We evaluated the type inference by giving it a variety of Python programs which focus on different Python features as well as one open source Python project (Chapter \ref{chapter:eval}).

Although the type inference is still in an early stage and imposes some restrictions on the supported programs, being the first to tackle the type inference problem with SMT solving poses many interesting questions and opens multiple possibilities for future research. The work on this tool does not stop with this thesis. We will keep enlarging the subset of the Python language which we support and increase the completeness of the tool.

\section{Future Work}
The focus of this work was to provide a model for developing static type inference of dynamically typed languages. The goal was to define a static type system for Python and type inference rules that are sound in terms of static type checking. Having this goal achieved, our goal now is to make the type inference reliable for large-scale projects. We are faced with the challenge of supporting a larger subset of the Python programs. We present here some of the research and contributions to this tool that we encourage to be done in the future.

\subsection{Error Reporting}
Currently, if the generated constraints are unsatisfiable, the conflicting constraints are returned. However, the whole program is rejected in this case and no types are inferred. One possible future improvement is giving types to the program constructs except the ones contributing to the unsatisfiability of the constraints.
\subsection{Modularity}
The input program may be divided into independent components, such that a separate SMT problem is concerned with inferring the types of each component. So instead of having only one SMT solver and giving all the collected constraints to it, solving the SMT problem can be distributed among multiple solvers. This will lead to a significant improvement in the inference performance, and can also contribute to the error reporting discussed above. To have such modularity, advanced pre-analysis is required to determine the flow graph of the program, and divide the program components accordingly.
\subsection{Infer Built-in Types with Class Definition Rules}
The encoding presented in \ref{sec:builtin_enc} treats the encoding of most commonly used built-in types separately from the encoding of class definitions, although every type in Python comes down to a class definition. The reason for this encoding is that the number of constraints generated for inferring the types of class definitions is huge compared to the ones generated by handling these built-in types separately. An interesting area of research in the future is applying the inference rules of the class definitions on these built-in types while maintaining fair performance. This will get rid of handling a lot of special cases, and accordingly will make the type inference more natural with respect to the type system of Python. Also, this will lift some of the current type system restrictions, like inheriting from built-in types.