% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Evaluation and Future Work}\label{chapter:eval}
Having explained the encoding for the type system in Z3 and the type inference rules and the constraints generated by different Python constructs, we discuss here the experiments we have done with the tool and discuss the current type inference limitations.

\section{Experimentation}
We evaluated the type inference on a variety of programs, some of which focus on a single functionality (like multiple inheritance, function calls, etc.), while another is an open source project available on GitHub. However, the open source project that we use in our experimentation was not meant to be statically typed when it was written, so some parts of this project oppose the restrictions imposed by having a nominal static type system for Python. An example of these conflicts is the following:

\begin{lstlisting}
class A:
	pass
	
class B(A):
	def f(self): ...

class C(A):
	def f(self): ...

def foo(x):
	x.f()
	
f(B())
f(C())
\end{lstlisting}
The type of the parameter \lstinline|x| in function \lstinline|foo| is inferred to be of type \lstinline|A| (The super type of both \lstinline|B| and \lstinline|C|). However, class \lstinline|A| does not implement the method \lstinline|f|, so the call \lstinline|x.f()| in the body of \lstinline|foo| is invalid, although it will not fail at runtime. Accordingly, we had to modify some parts of the project we used to fit the limitations imposed by having a static type system. In the above example, we add an abstract method \lstinline|f| to class \lstinline|A|. After the types of these programs are inferred and the typed source code is generated, we run mypy \cite{mypy} to statically check these types and verify that the inference produced a correct result.
\subsection{IMP Interpreter}
IMP \cite{imp} is a simple programming language developed in the 1970s. An interpreter for the language \cite{imp_i} was created by Jay Conrod as an example of building interpreters. This interpreter is an excellent testing material for our type inference for many reasons:

\begin{itemize}
	\item It does not violate any of the restrictions discussed in \ref{sub:st_ts_3}.
	\item It extensively uses most of the Python patterns that we support, like inheritance, callable objects, operator overloading and using built-in libraries.
	\item It is composed of more than 1000 lines of code, which is comparable to most Python projects.
\end{itemize}
The inference for this project runs in 12 seconds on \textit{8-core 3.6 GHz Intel Core i7} processor, which gives a prospect that the performance of the constraints solving is capable of handling a large portion of regular-sized projects.

\subsection{Functionality Specific Programs}
Some programs used for evaluation focus on specific functionalities supported by the type inference (e.g., multiple inheritance, inheritance variance relationships, built-ins, etc.). For example, the following program is used to test the method resolution order in the presence of multiple inheritance.
\begin{lstlisting}
class A:
	def who_am_i(self):
		return A


class B(A):
	pass


class C(A):
	def who_am_i(self):
		return C


class D(B, C):
	pass

d1 = D()
who = d1.who_am_i()

"""With the old MRO algorithm, the type of `who` would be Type[A],
because the naive DFS will reach A before C
With the C3 Linearization algorithm, C will appear first in the
search context, so the type of `who` is Type[C]
"""

# A := Type[A]
# B := Type[B]
# C := Type[C]
# D := Type[D]
# d1 := D
# who := Type[C]
\end{lstlisting}

To verify that the type inference is correct for these programs, we write the expected types for the variables in comments at the end of the program (e.g., \lstinline|A := Type[A]|), then after the SMT problem is solved and the types model is given, we parse these special comments and compare the types given to each variable in the model against the specified ones in the comments.
\section{Limitations}
Section \ref{sub:st_ts_3} states the restrictions imposed on the dynamic nature of Python by defining a static type inference for the language. We list here the limitations of the type inference which are allowed by the definition of the type system.

\begin{enumerate}
\item Using reflective or introspective properties of Python is not supported.
\item Modifying global variables using \lstinline|global| keyword is not supported.
\item It is not possible to dynamically create and infer modules during runtime.
\item \lstinline|exec| and \lstinline|eval| commands are not supported.
\item It is not possible to define new function decorators, and using built-in decorators is currently limited to \lstinline|@staticmethod| and \lstinline|@abstractmethod| decorators.
\item Tuple assignments support only tuples not lists as assignment values. Similarly, list assignments support only lists as assignment values. For example, the following two assignments are not supported:
\begin{lstlisting}
a, b = [1, 2]  # Cannot assign list to tuple
[a, b] = 1, 2  # Cannot assign tuple to list
\end{lstlisting}
This limitation is put to decrease the number of generated constraints when any of such kind of assignments is encountered, and hence increase the inference performance.

\item \lstinline|super| calls are not supported due to the reasons discussed in Section \ref{more_mult}.

\item Functions containing generic type variables and stub functions cannot be used as first class objects. They only support direct function calls.
\item Imported module via \lstinline|import| statement cannot be used as first class objects.

\item Classes in the whole program must have unique names even if they belong to different modules.
\end{enumerate}
