% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Type System Encoding in Z3}\label{chapter:ts}
As mentioned earlier, we depend primarily on Z3 to provide a model in which a type is assigned to each construct in the Python program which satisfies the constraints imposed by the type system. In order to have such kind of constraints, the types of the type system are simulated using Z3 data-types, while the rules governing the subtype relationships in this type system are encoded with Z3 uninterpreted functions. We explain in this chapter the encoding of these types and rules in Z3.
\section{Types Encoding}
A Python type is encoded in Z3 with a data-type declaration, which we call \textit{type sort}. From this data-type, multiple constructors are declared, each representing a corresponding type in the Python type system.\\

\subsection{Built-ins}
Most built-in types are simply declared with a \textit{type sort} constructor. If a built-in type is composed of other one or more types (e.g., lists, dictionaries, etc.), accessor arguments representing these types are declared within the constructor declaration. Below is a listing, written in Z3Py, of some types declarations from the \textit{type sort} data-type.

\begin{lstlisting}[language=python]
type_sort = Datatype("type sort")

type_sort.declare("object")
type_sort.declare("type", ("instance", type_sort))
type_sort.declare("none")
type_sort.declare("complex")
type_sort.declare("float")
type_sort.declare("int")
type_sort.declare("bool")
type_sort.declare("str")
type_sort.declare("bytes")
type_sort.declare("list", ("list_type", type_sort))
type_sort.declare("set", ("set_type", type_sort))
type_sort.declare("dict", ("dict_key_type", type_sort), ("dict_value_type", type_sort))

...
type_sort = type_sort.create()
\end{lstlisting}

Notice that after defining all the constructors, we call the \lstinline|create()| method to declare the actual data-type itself that we will be using in the inference. For this reason, all the types constructors have to be available before attempting to infer the program types. This introduces the need to perform some pre-analysis for the program being inferred to get knowledge of the types that are naturally not available before inspecting the source code. We will discuss these types in the upcoming sections.

\subsection{Functions and Tuples}
One thing that is not straightforward to encode is types that consist of a collection of other types, like tuples or functions, since tuples and function arguments may have arbitrary number of elements.

Unfortunately, Z3 does not currently support combining data-type declarations with arrays or sets. To work around this limitation, we perform a pre-analysis of the whole input program which provides the maximum length of tuples and the arguments of functions that appear in the program, then we declare a separate constructor for every possible length of tuples and functions. Moreover, the user of the type inference has the ability to explicitly define the maximum number of function arguments and tuple elements without using the ones provided by the pre-analyzer.\\

Now having the maximum length of functions arguments and tuples, the types of functions and tuples can be encoded as follows:

\begin{lstlisting}[language=python]
# Functions declaration
for cur_len in range(max_function_args + 1):
    accessors = []
    # create accessors for the argument types of the function
    for arg in range(cur_len):
	    accessor = ("func_{}_arg_{}".format(cur_len, arg + 1), type_sort)
	    accessors.append(accessor)
    # create accessor for the return type of the function
    accessors.append(("func_{}_return".format(cur_len), type_sort))
    
    # declare type constructor for the function
    type_sort.declare("func_{}".format(cur_len), *accessors)

# Tuples declaration
for cur_len in range(max_tuple_length + 1):
    accessors = []
    # create accessors for the tuple
    for arg in range(cur_len):
		accessor = ("tuple_{}_arg_{}".format(cur_len, arg + 1), type_sort)
	    accessors.append(accessor)
	    
    # declare type constructor for the tuple
    type_sort.declare("tuple_{}".format(cur_len), *accessors)
\end{lstlisting}

A constructor is created for every length of functions and tuples, and accessor for each of their arguments is added to the corresponding constructor.

\subsection{User-defined Types}
Similarly, each user-defined type has its own constructor declaration from the \textit{type sort} data-type. However, since all the types constructors have to be available before running the inference algorithm, we use the program pre-analyzer to provide a listing of all classes that are used in the whole program. Then a type constructor is created for each of these classes. 

\begin{lstlisting}[language=python]
for cls in get_all_classes(program):
	type_sort.declare("class_{}".format(cls))
\end{lstlisting}

Moreover, the pre-analyzer provides information about the methods and the attributes of these classes. An uninterpreted constant is declared for each of these methods and attributes, and each class is mapped to the constants corresponding to its own attributes.

\begin{lstlisting}
class_to_attrs = some_pre_analysis_function(program)
class_to_z3_consts = {}

for cls in class_to_attrs:
    attrs = class_to_attrs[cls]
    class_to_z3_consts[cls] = {}
    
    # Create Z3 constants for all attributes
    for attr in attrs:
	    attribute = Const("class_{}_attr_{}".format(cls, attr), type_sort)
	    class_to_z3_consts[cls][attr] = attribute
\end{lstlisting}

Now the types of the type system defined in the previous chapter are encoded in Z3. Note that, and as discussed earlier, other built-in types are not mentioned here since they are inferred as user-defined types when they are encountered as class definitions in the stub files.\\

It is worth mentioning that all the built-in types could be encoded the way user-defined class are encoded, since every type in Python 3 is a class definition. However, classes inference has significant costs in terms of performance. Therefore, it was more convenient to encode the most common built-in types, like \lstinline|int|, \lstinline|float|, etc., with separate constructors.

\section{Subtyping Rules Encoding}\label{sec:sub_encode}
Having explained the encoding of the types in Z3, we explain here how the subtype relationships between these types are encoded. The subtype relationships discussed in the previous chapter are encoded using an uninterpreted function \lstinline|subtype|, which takes two types, encoded in the \textit{type sort} data-type, as its arguments and returns a \lstinline|Bool| sort.
\begin{lstlisting}
subtype = Function("subtype", type_sort, type_sort, BoolSort())
\end{lstlisting}

The encoding works by constructing a directed acyclic graph (DAG) representing the inheritance, such that each node in the DAG represents a type in the type system, and each edge from a node \lstinline|x| to a node \lstinline|y|, denoted by \lstinline|edge(x,y)|, indicates that type \lstinline|y| is a direct subtype of (inherits from) type \lstinline|x|. Then using the information deduced from the DAG, the axioms for the subtyping are generated using the \lstinline|subtype| function defined above according to the following conditions:
\[
	subtype(x,y) = \left\{
	\begin{array}{@{}l@{\thinspace}l}
	True & : x == y \lor edge(y, x) \lor \exists z : edge(y, z) \land subtype(x, z) \\
	False & : otherwise\\
	
	\end{array}
	\right.
\]

Such that for every type, disjunctions for its super classes and sub classes are added to the Z3 solver. For example, the following disjunctions are added for the \lstinline|int| type:

\begin{lstlisting}
ForAll(x, subtype(x, int) == 
	Or(
		x == bool,
		x == int
	)
)

ForAll(x, subtype(int, x) == 
	Or(
		x == int,
		x == float,
		x == complex,
		x == object
	)
)
\end{lstlisting}

Figure \ref{fig:dag} shows a subgraph of the constructed DAG with a subset of the subtype relationships between built-in types.

\begin{figure}
	\begin{mdframed}
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
		semithick]
		
		\node[] (object) at (7,6) {object};
		\node[] (None) at (0,3) {None};
		\node[] (complex) at (2,3) {complex};
		\node[] (float) at (2,2) {float};
		\node[] (int) at (2,1) {int};
		\node[] (bool) at (2,0) {bool};
		\node[] (str) at (4,3) {str};
		\node[] (bytes) at (6,3) {bytes};
		\node[] (Tuple[t*]) at (8,3) {Tuple[t*]};
		\node[] (Set[t]) at (10,3) {Set[t]};
		\node[] (List[t]) at (12,3) {List[t]};
		
		\path [->] (object) edge (None);
		\path [->] (object) edge (complex);
		\path [->] (object) edge (str);
		\path [->] (object) edge (bytes);
		\path [->] (object) edge (Tuple[t*]);
		\path [->] (object) edge (Set[t]);
		\path [->] (object) edge (List[t]);
		\path [->] (complex) edge (float);
		\path [->] (float) edge (int);
		\path [->] (int) edge (bool);	
		\end{tikzpicture}
	\end{mdframed}
	\caption{Subgraph of the constructed inheritance DAG}
	\label{fig:dag}
\end{figure}

\subsection{Builtins with Generic Types}\label{sec:builtin_generic_encoding}
To generate the subtype axioms for types containing generics (e.g., lists, dicts and tuples), a universal quantification is performed over all possible types for the generics. The example below, in Z3Py syntax, shows the generated axiom for the subtype relationship between lists and \lstinline|object|:
\begin{lstlisting}
ForAll([x, y], subtype(List(x), y) ==
	Or(
		y == List(x)
		y == object,
	)
)
\end{lstlisting}

\subsection{User-defined Types}
The pre-analysis provides a mapping from every class to its super class(es). If a class has no explicitly declared super classes, it is mapped to \lstinline|object| type. Then the edges for every direct subtype relationship deduced from the pre-analysis are added to the inheritance DAG. \\

We will elaborate more in the next chapter on inheritance between user-defined classes. Specifically, we will talk about the method resolution order (MRO), which is the order in which methods and attributes are resolved in the presence of multiple inheritance, and how it is handled in our type inference. We will also discuss the variance relationships between the overriding and the overridden methods.\\

Now that the encoding of both types and subtype rules of the type system in Z3 is fully explained, we are ready to explain the design and the implementation of our type inference in the next chapter.