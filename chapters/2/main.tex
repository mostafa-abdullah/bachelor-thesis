% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Background Information}\label{chapter:background}

\section{Related Work}
Many attempts have been made to infer types for Python, each of which had its own goals and limitations. We discuss here some work that we have studied, and we present some of their limitations and how similar and/or different they are from our tool.

\subsection{Type Inference Algorithms}
There are two type inference algorithms primarily used at the time of writing this thesis: Hindley-Milner algorithm and the Cartesian Product algorithm.

\subsubsection{Hindley-Milner}
% TODO
\subsubsection{Cartesian Product}
% TODO

\subsection{Mypy \cite{mypy}}
Mypy is a static type checker for Python. It depends on defining type annotations for almost all the constructs in the Python program to be checked. In addition, it performs local type inference. However, this type inference cannot be extended beyond local scopes. It requires that function definitions to be fully type-annotated and cannot infer function calls whose return type annotation is not specified. For example, mypy will fail to infer the type of variable \lstinline|x| in the following program:

\begin{lstlisting}[language=Python]
def f():
	return "string"

x = f()  # Infer type Any for x
\end{lstlisting}

What mypy intends to provide is closely related to the goal of our tool, that is to provide static type checking for the program. However, we aim to reduce (and sometimes eliminate) the writing overhead in defining the type annotations for the program constructs.


\subsection{InferÃªncia de tipos em Python \cite{porto}}
The thesis \cite{porto} describes a static type system defined for a restricted version of RPython, and presents static type inference ideas based on this type system. The work presented in \cite{porto} also describes type inference implementation for Python expressions (like numbers, lists, dictionaries, binary and
unary operations, etc.), assignment statements and conditional statements. It also gives an idea about inferring polymorphic and non-polymorphic function calls, class definitions and class instantiation. However, the approach they take has a handful of limitations and is not applicable to real Python code. It does not describe inferring function arguments, which is a critical step in the inference of function definitions and function calls. Accordingly, and similar to mypy, the inference they present is not extensible beyond local scopes inference.


\section{SMT Solving with Z3 \cite{z3}}
\textbf{Satisfiability Modulo Theories (SMT)} is a decision problem for first-order logic formulas. Which means, it is the problem which determines whether a given first-order logic formula, whose variables may have several interpretations, is satisfiable or not.

SMT solving is a generalization of boolean satisfiability (SAT) solving. It can reason about a larger set of first-order theories than SAT theories, like those involving real numbers, integers, bit vectors and arrays.\\

\textbf{Z3 \cite{z3}} is an efficient SMT solver, developed by Microsoft Research in 2007 with built-in support for theories of linear and nonlinear arithmetic, bit vectors, arrays, data-types, quantifiers and strings.

Z3 is now widely used in software analysis and program verification. For instance, 50 bugs were found in Windows kernel code after using Z3 to verify Windows components.\\

In our static type inference tool, we depend primarily on Z3 to provide a types model that satisfies all the Python program semantics.

\subsection{Z3 semantics}
We explain here all the relevant Z3 semantics that we will be using in our tool. For convenience, we will provide the explanation of these semantics in Z3Py, a Python interface for the Z3 solver, since we will be using this interface semantics throughout this thesis. This section targets those who are new to Z3. Those who are already familiar with these Z3 semantics can skip this section.

\subsubsection{Z3 Sort}
It is the building component of Z3 type system. \textbf{Sorts} in Z3 are equivalent to \textbf{data types} in most programming languages. Examples of a sort in Z3 include \lstinline|Bool|, \lstinline|Int| and \lstinline|Real|.

\subsubsection{Constant}
It is a symbol that builds the first-order formula which we are trying to solve with Z3. A Z3 solution to the SMT problem will assign a value to this constant that satisfies the given formula.

Each constant in Z3 has its own type (sort), and the value assigned to it in the SMT solution is of the same sort as this constant. The following example declares two constant, namely \lstinline|x| and \lstinline|y|, of type \lstinline|Int| and queries Z3 for a solution for the given constraints.

\begin{lstlisting}[language=python]
x = Int("x")
y = Int("x")
solve(x == 1, y == x + 1)

# model: x = 1, y = 2
\end{lstlisting}

A constant of any sort can be created with the following syntax:

\begin{lstlisting}[language=python]
x = Const("x", some_sort)
y = Const("y", IntSort())
\end{lstlisting}

\subsubsection{Axiom}
It is the constraint imposed on problem constants that needs to be satisfied by values assigned to these constants. In the example above, \lstinline|x == 1| and \lstinline|y == x + 1| are two axioms.

Any Z3 expression that can evaluate to the Z3 \lstinline|Bool| sort can qualify as a Z3 axiom. For instance, \lstinline|x < y + x + 2|, \lstinline|y != 0| and \lstinline|x <= y| are all Z3 axioms.


\subsubsection{Logical Connectives}
Z3 supports most commonly used logical connectives in first-order logic. It supports negation (not), conjunction (and), disjunction (or), implication and bi-implication (equivalence). The syntax for these connectives in Z3Py is given below.\\
\textbf{Negation}: \lstinline|Not(some_axiom)|\\
\textbf{Conjunction}: \lstinline|And(one_or_more_axioms)|\\
\textbf{Disjunction}: \lstinline|Or(one_or_more_axioms)|\\
\textbf{Implication}: \lstinline|Implies(first_axiom, second_axiom|\\
\textbf{Bi-implication}: \lstinline|first_axiom == second_axiom|\\


\subsubsection{Functions}
Functions are the basic building blocks of the SMT formula. Every constant can be considered as a function which takes no arguments and returns this constant.
Z3 functions are \textbf{total} that is they are defined for all the domain elements. Moreover, functions (and constants) in Z3 are called \textbf{uninterpreted}, that is they allow any interpretation (may be more than one) which is consistent with the imposed constraints. Which means there is no prior interpretation attached before solving the SMT problem. Therefore, we may use the terms uninterpreted constant and variable interchangeably.

Z3 functions map one or more sort (type) of the domain to a result sort.

Below is an example that illustrates uninterpreted functions and constants.

\begin{lstlisting}[language=python]
x = Int('x')
y = Int('y')
f = Function('f', IntSort(), IntSort())
solve(f(f(x)) == x, f(x) == y, x != y)

# model:
# x = 0, y = 1, f = [0 -> 1, 1 -> 0, else -> 1]
\end{lstlisting}

\subsubsection{Data-types}
Z3 provides a convenient way for declaring algebraic data-types (a kind of composite data-types), which is a sort that can constructed from other sorts or data-types.

Before going through an example, it is important to define two constructs in Z3 data-types: Constructors and accessors. With a \textbf{constructor}, different variants of the data-type can be created. Each of these variants may have its own typed attributes. An \textbf{accessor} is a function that can fetch these attributes stored within a data-type instance.

The following example demonstrates declaring and using data-types in Z3. We create a data-type representing a binary tree. The node of this tree may have two variants: Either a leaf with some value attached to it, or an inner node with left and right references two its left and right subtrees respectively.

\begin{lstlisting}[language=python]
Tree = Datatype("Tree")

Tree.declare("leaf", ("value", IntSort()))
Tree.declare("inner_node", ("left", Tree), ("right", Tree))

Tree = Tree.create()

leaf_constructor = Tree.leaf
inner_node_constructor = Tree.inner_node

left_accessor = Tree.left
right_accessor = Tree.right
value_accessor = Tree.value
\end{lstlisting}

A constructor is declared for each variant of the tree node. The leaf has an \lstinline|Int| attribute representing the value it carries. The \lstinline|inner_node| constructor has two arguments. Each attribute has its own accessor function.

Below on the left is an example of encoding the tree on the right using the example above.


\begin{minipage}[c]{0\textwidth}
	\begin{flushleft}
\begin{lstlisting}[language=python]
leaf_1 = leaf_constructor(10)
leaf_2 = leaf_constructor(20)
leaf_3 = leaf_constructor(30)

node_2 = inner_node_constructor(leaf_1, leaf_2)
node_1 = inner_node_constructor(node_2, leaf_3)
\end{lstlisting}
	\end{flushleft}
\end{minipage}%
\begin{minipage}[c]{1.1\textwidth}
	\begin{flushright}
		\Tree[.{node 1} [.{node 2} {leaf 1 (10)} {leaf 2 (20)} ] {leaf 3 (30)} ]
	\end{flushright}
\end{minipage}


\subsubsection{Quantifiers}
In addition to quantifier-free formulas, Z3 can also solve formulas involving quantifiers. Z3 uses different approaches to solve formulas with quantifiers. The only one which we are concerned with and we will be using in our type inference tool is the \textit{pattern-based quantifier instantiation} approach. This approach works by annotating the quantified formula with some pattern annotations, and these formulas are only instantiated when these patterns are matched during the search context.

Z3 supports two kinds of quantifiers: \textit{Universal} and \textit{Existential} quantifiers.

Below is an example demonstrating using both kinds of quantifiers in Z3Py.

\begin{lstlisting}
x = Int('x')
f = Function('x', IntSort(), IntSort())

ForAll(x, f(x) == x, patterns=[f(x)])

y = Int('y')
Exists(y, x + y == 2)
\end{lstlisting}

The above two axioms are equivalent to the below in first-order logic syntax:\\
\begin{center}
	$\forall x\in \mathbb{Z}$, \lstinline|f(x) = x| \\
	$\exists y\in \mathbb{Z}$, \lstinline|x + y = 2|
\end{center}


\section{Type System}
A type system is the set of rules that assign the types to different constructs of the program, such that constructs which have the same type share common behavioral properties. The type system is useful in preventing the occurrences of certain types of errors before or during the program execution.

Each programming language defines the rules for its type system, and the language compilers and/or interpreters are built based on this type system. The process of verifying that the program satisfies the rules enforced by the language's type system is called \textit{type checking}. There are two types of type checking: \textit{static type checking} and \textit{dynamic type checking}. Accordingly, programming languages are divided to \textit{statically-typed} and \textit{dynamically-typed} languages according to the type checking they perform.

\subsection{Static Type and Dynamic Type Checking}

\textbf{Static type checking} is done at compile time. Therefore, the types for every construct in the program must be available before compiling the code. Most statically-typed programming languages, like Java, enforce the programmer to declare the types for every construct. However, there are some languages, like Haskell, that employ type inference to statically deduce the types of the program constructs.

One benefit of static type checking is the early detection of type errors. Therefore, statically-typed languages are generally type-safer than dynamically-typed ones. Also, static typing contributes to the program readability and accordingly its maintainability.\\

On the other hand, \textbf{Dynamic type checking} is performed during runtime, where each object gets assigned to its type during the program execution. Programming languages that perform only dynamic type checking are classified as dynamically-typed languages. One of the advantages of dynamically-typed languages over the statically typed ones is that programs tend to be simpler and more flexible.


\subsection{Subtyping}
Subtyping is a feature which exists in object oriented programming, which allows a form of substitution.

